{
  "_args": [
    [
      {
        "raw": "promish@>=5.0.2",
        "scope": null,
        "escapedName": "promish",
        "name": "promish",
        "rawSpec": ">=5.0.2",
        "spec": ">=5.0.2",
        "type": "range"
      },
      "C:\\Users\\efc1980\\Desktop\\devdir\\node_modules\\exceljs"
    ]
  ],
  "_from": "promish@>=5.0.2",
  "_id": "promish@5.0.2",
  "_inCache": true,
  "_location": "/promish",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/promish-5.0.2.tgz_1489653545720_0.7182920286431909"
  },
  "_npmUser": {
    "name": "guyonroche",
    "email": "cyber.sapiens@hotmail.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {},
  "_requested": {
    "raw": "promish@>=5.0.2",
    "scope": null,
    "escapedName": "promish",
    "name": "promish",
    "rawSpec": ">=5.0.2",
    "spec": ">=5.0.2",
    "type": "range"
  },
  "_requiredBy": [
    "/exceljs"
  ],
  "_resolved": "https://registry.npmjs.org/promish/-/promish-5.0.2.tgz",
  "_shasum": "2546a86c79d91408ab40e9d86c88963ea4c7e9b8",
  "_shrinkwrap": null,
  "_spec": "promish@>=5.0.2",
  "_where": "C:\\Users\\efc1980\\Desktop\\devdir\\node_modules\\exceljs",
  "author": {
    "name": "Guyon Roche",
    "email": "guyon@live.com",
    "url": "https://github.com/guyonroche/promish"
  },
  "bugs": {
    "url": "https://github.com/guyonroche/promish/issues"
  },
  "dependencies": {
    "es6-promise": "^3.0.2"
  },
  "description": "ES6 Promise Shim",
  "devDependencies": {
    "babel-polyfill": "^6.23.0",
    "babel-preset-es2015": "^6.22.0",
    "bluebird": "*",
    "browserify": "^14.1.0",
    "browserify-shim": "^3.8.13",
    "chai": "*",
    "grunt": "^1.0.1",
    "grunt-babel": "^6.0.0",
    "grunt-browserify": "^5.0.0",
    "grunt-contrib-concat": "^1.0.1",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-jasmine": "^1.1.0",
    "grunt-contrib-uglify": "^2.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "jshint": "2.8.x",
    "mocha": "*",
    "pinkie": "*",
    "q": "*",
    "uglifyjs": "^2.4.10"
  },
  "directories": {},
  "dist": {
    "shasum": "2546a86c79d91408ab40e9d86c88963ea4c7e9b8",
    "tarball": "https://registry.npmjs.org/promish/-/promish-5.0.2.tgz"
  },
  "engines": {
    "node": ">=6.0.0"
  },
  "files": [
    "lib",
    "dist",
    "LICENSE",
    "README.md"
  ],
  "gitHead": "20d2c6b5f5d6d14c5df8907b8ef2e5adc23cc60d",
  "homepage": "https://github.com/guyonroche/promish#readme",
  "keywords": [
    "ES6",
    "Promise",
    "Shim",
    "EcmaScript",
    "Promises",
    "resolve",
    "reject",
    "then",
    "catch",
    "finally",
    "race",
    "all",
    "any",
    "some",
    "spread",
    "Promisify",
    "Promisification",
    "call",
    "apply",
    "map",
    "reduce"
  ],
  "license": "MIT",
  "main": "lib/promish.js",
  "maintainers": [
    {
      "name": "guyonroche",
      "email": "cyber.sapiens@hotmail.com"
    }
  ],
  "name": "promish",
  "optionalDependencies": {},
  "private": false,
  "readme": "# Promish\r\n\r\n```javascript\r\n     SH\r\n      I\r\nP R O M\r\n```\r\n\r\nThe Promish module creates a wrapper around the EcmaScript 6 Promise class (and others).\r\n It adds some of the useful features found in many of the other popular promise libraries such as Q and Bluebird.\r\n It is designed to be interchangeable with the ES6 Promise as its interface is a superset of the Promise class.\r\n\r\nI have strived to keep this library as small as practicable while offering as much functionality as possible.\r\n  As it stands, the minified browserified bundle is less than 14k!\r\n\r\n# Installation\r\n\r\nnpm install promish\r\n\r\n# New Features!\r\n\r\n<ul>\r\n    <li>\r\n        Browserification\r\n        <ul>\r\n            <li>\r\n                The Promish class has been reworked to allow the base-promise class it extends to be injected\r\n                so that a browser friendly promise can be used for the browserify build. The implementation I\r\n                am using for this is <a href=\"https://www.npmjs.com/package/es6-promise\">es6-promise</a>.\r\n            </li>\r\n            <li>\r\n                The standard Promish implementation (via require('promish') has not been affected and will still\r\n                deliver a Promish class that extends the native Promise.\r\n            </li>\r\n            <li>\r\n                See <a href=\"#browserification\">Browserification</a> for details.\r\n            </li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"#map\">map</a>\r\n        <ul>\r\n            <li>map takes an array of values or promises and calls a supplied callback function on each resolved value finally resolving in an array of values</li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"#reduce\">reduce</a>\r\n        <ul>\r\n            <li>reduce takes an array of values or promises and calls a supplied callback function on each resolved value in a sequential fashion resolving to a single value</li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\n# Contents\r\n\r\n<ul>\r\n    <li>\r\n        <a href=\"#interface\">Interface</a>\r\n        <ul>\r\n            <li><a href=\"#include\">Include</a></li>\r\n            <li><a href=\"#instantiation\">Instantiation</a></li>\r\n            <li><a href=\"#then\">Then</a></li>\r\n            <li><a href=\"#catch\">Catch</a></li>\r\n            <li><a href=\"#finally\">Finally</a></li>\r\n            <li>\r\n                <a href=\"#promisification\">Promishification</a>\r\n                <ul>\r\n                    <li><a href=\"#apply\">Apply</a></li>\r\n                    <li><a href=\"#call\">Call</a></li>\r\n                    <li><a href=\"#post\">Post</a></li>\r\n                    <li><a href=\"#invoke\">Invoke</a></li>\r\n                    <li><a href=\"#promisify\">Promisify</a></li>\r\n                    <li><a href=\"#promisify-all\">Promisify All</a></li>\r\n                    <li><a href=\"#method\">Method</a></li>\r\n                </ul>\r\n            </li>\r\n            <li><a href=\"#race\">Race</a></li>\r\n            <li><a href=\"some\">Some</a></li>\r\n            <li><a href=\"#any\">Any</a></li>\r\n            <li><a href=\"#spread\">Spread</a></li>\r\n            <li><a href=\"#map\">Map</a></li>\r\n            <li><a href=\"#reduce\">Reduce</a></li>\r\n        </ul>\r\n    </li>\r\n    <li><a href=\"#browserification\">Browserification</a></li>\r\n    <li><a href=\"#known-issues\">Known Issues</a></li>\r\n    <li><a href=\"#release-history\">Release History</a></li>\r\n</ul>\r\n\r\n# Interface\r\n\r\n## Include\r\n\r\n```javascript\r\nvar Promish = require('promish');\r\n```\r\n\r\n## Instantiation\r\n\r\n### Typical use - construct with handler function\r\n\r\n```javascript\r\nvar promise = new Promish(function(resolve, reject) {\r\n  // do something async\r\n});\r\n```\r\n\r\n### 3rd Party Wrapper Mode\r\n\r\n```javascript\r\nvar promise = new Promish(Q());\r\n\r\nvar promise = new Promish(new Promise( ... ));\r\n```\r\n\r\n### Value Wrapper Mode\r\n```javascript\r\n// If the constructor value is not a function, a thenable or an Error,\r\n// assume it should be a resolve value.\r\nvar promise = new Promish('Resolve Value');\r\n\r\n// To explicitly signal resolve, use Promish.resolve\r\nvar promise = Promish.resolve('Resolve Value');\r\n```\r\n\r\n### Error Wrapper Mode\r\n```javascript\r\n// If the constructor value is an Error type, it will be interpreted as rejection\r\nvar promise = new Promish(new Error('This promise is rejected'));\r\n\r\n// To explicitly signal something is rejection use Promish.reject\r\nvar promise = Promish.reject('This is not an error object, but reject with it anyway')\r\n```\r\n\r\n\r\n\r\n## Then\r\n\r\n```javascript\r\n// typical use\r\npromise\r\n  .then(function(value) {\r\n    // something async has completed with a value\r\n    // here you can return a resolve value,\r\n    // return a new Promish or throw an error (handled as rejection)\r\n  });\r\n  \r\n// with onRejected...\r\npromise.then(\r\n  function(value) {\r\n  },\r\n  function(error) {\r\n  });\r\n```\r\n\r\n## Catch\r\n\r\nThe catch function takes a catch handler that will be called when the promise state is rejected\r\n and is a more elegant way to handle errors than using the second then argument.\r\n\r\n```javascript\r\n// catch all\r\npromise\r\n  .catch(function(error) {\r\n    // Something async has failed with an error.\r\n    // Just like with then(), you can return a resolve value,\r\n    // return a new Promish or throw a new error (handled as rejection)\r\n    // You can also 'rethrow' the error by returning a new Promish\r\n    // with the error\r\n  });\r\n```\r\n\r\nPromishes also support Error type matching\r\n\r\n```javascript\r\nnew Promish(function(resolve, reject) {\r\n    resolve(JSON.parse(text));\r\n  })\r\n  .then(function(json) { ... })\r\n  .catch(SyntaxError, function(error) {\r\n    // only called if error is instanceof SyntaxError\r\n  })\r\n  .catch(function(error) {\r\n    // will be called for other types of error\r\n  });\r\n```\r\n\r\nAnd also support user supplied error match functions\r\n\r\n```javascript\r\nfunction isFooString(value) {\r\n  return ((typeof value) === 'string') && (value.indexOf('foo') >= 0);\r\n}\r\n\r\npromise\r\n  .then(function(value) { ... })\r\n  .catch(isFooString, function(error) {\r\n    // error is a string and contains 'foo'\r\n  })\r\n  .catch(function(error) {\r\n    // called if the not a foo string\r\n  });\r\n```\r\n\r\n## Finally\r\n\r\nA finally handler will be called no matter what state the promise chain gets into.\r\n There are no arguments provided to the finally handler and the downstream promise state will typically reflect\r\n the state of the promise before the finally handler is called.\r\n If the finally handler returns a promise, finally will wait for the promise to resolve before propagating the\r\n incoming promise value.\r\n If the finally handler's promise is rejected, the new rejected state will override the incoming promise state\r\n and the new state will take on the new rejection state of the finally handler's promise.\r\n This will also be the case if the finally handler throws an exception.\r\n\r\n```javascript\r\n// catch all\r\npromise\r\n  .then(function(value) { ... })\r\n  .catch(function(error) { ... })\r\n  .finally(function() {\r\n    // clean stuff up\r\n  })\r\n```\r\n\r\n## Delay\r\n\r\nPause for a number of milliseconds and then continue.\r\n The resolve value will be preserved.\r\n If the promish state is rejected, delay will not delay and will preserve the rejection error\r\n\r\n```javascript\r\ngetAPromish()\r\n  .delay(1000)\r\n  .then(function(value) {\r\n    // continue 1 second later\r\n  })\r\n  .catch(function(error) {\r\n    // there was an error, process immediately\r\n  });\r\n```\r\n\r\n## Defer\r\n\r\nFor compatability with the old Promise.defer() pattern...\r\n\r\n```javascript\r\nfunction readAFile(filename) {\r\n  var deferred = Promish.defer();\r\n  \r\n  fs.readFile(filename, function(error, data) {\r\n    if (error) {\r\n      deferred.reject(error);\r\n    } else {\r\n      deferred.resolve(data);\r\n    }\r\n  });\r\n  \r\n  return deferred.promise;\r\n}\r\n```\r\n\r\n## Promisification Calls\r\n\r\nThe majority of the old asynchronous Node methods follow a basic pattern where the last argument in a function\r\n is a callback function and the first argument of that callback function is used to signal errors -\r\n if the error argument is truthy, then the call failed and the value of the error will indicate why,\r\n otherwise the call succeeded.\r\n\r\nPromisification involves converting the async pattern into promises - either on the fly or by wrapping functions,\r\n methods or even whole objects...\r\n\r\n### Apply\r\n\r\n```javascript\r\n// Note: Promish.nfapply alias included for Q compatability\r\nPromish.apply(fs.readFile, [filename])\r\n  .then(function(data) {\r\n    // oooh data!\r\n  })\r\n  .catch(function(error) {\r\n    // handle failure\r\n  });\r\n```\r\n\r\n### Call\r\n\r\n```javascript\r\n// Note: Promish.nfcall alias included for Q compatability\r\nPromish.call(fs.readFile, filename)\r\n  .then(function(data) {\r\n    // oooh data!\r\n  })\r\n  .catch(function(error) {\r\n    // handle failure\r\n  });\r\n```\r\n\r\n### Post\r\n\r\n```javascript\r\n// call method of target with arguments inline\r\n// Note: Promish.npost alias\r\nPromish.invoke(target, value1, value2)\r\n  .then(function(value) { ... });  \r\n```\r\n\r\n### Invoke\r\n\r\n```javascript\r\n// invoke method of target with array of arguments\r\n// Note: Promish.ninvoke alias\r\nPromish.invoke(target, [value1, value2])\r\n  .then(function(value) { ... });  \r\n```\r\n\r\n### Promisify\r\n\r\nConvert a function from async to promise for future use.\r\n\r\n```javascript\r\nvar readFile = Promish.promisify(fs.readFile);\r\n\r\nreadFile(filename)\r\n  .then(function(data) { ... })\r\n```\r\n\r\n### Promisify All\r\n\r\nPromisify all the async methods of an object.\r\n\r\nThere are two modes supported:\r\n* Proxy Mode (default)\r\n  * Creates a separate object that contains promisified methods for each method of the target object. The methods typically have the same name\r\n  * Note: ES6 Proxies eagerly awaited here!\r\n* In-Place Mode\r\n  * Adds promisified methods to the object, typically with a suffix to avoid colliding with the actual methods.\r\n\r\n```javascript\r\n\r\n// Proxy mode:\r\nvar fs = Promish.promisifyAll(require('fs'));\r\nfs.readFile(filename)\r\n  .then(function(data) { ... });\r\n\r\n// In-Place Mode\r\nvar fs = Promish.promisifyAll(require('fs'), { inPlace: true, suffix: 'Async' });\r\nfs.readFileAsync(filename)\r\n  .then(function(data) { ... });\r\n\r\n```\r\n\r\n### Method\r\n\r\nWrap a synchronous function or method so that it always returns a promise\r\n\r\n```javascript\r\nvar myFunc = Promish.method(function(value) {\r\n  // can throw\r\n  if (!value) throw new Error('Not zero!');\r\n  \r\n  // can return value\r\n  if (value > 0) return value;\r\n  \r\n  // can return promish()\r\n  return Promish.resolve(value);\r\n});\r\n\r\nmyFunc(1234)\r\n  .then(function(value) {\r\n    // ...\r\n  });\r\n\r\n// also works as member functions\r\nMyClass.prototype.func = Promish.method(function(value) {\r\n  // this is what you think it is\r\n  return this.value = value;\r\n});\r\n\r\nnew MyClass(7).func\r\n  .then(function(value) {\r\n    // ...\r\n  });\r\n\r\n```\r\n\r\n## All\r\n\r\nPromish wraps the native implementation of all.\r\n\r\n```javascript\r\nPromish.all([getPromise1(), getPromise2()])\r\n  .then(function(values) { ... });\r\n```\r\n\r\n## Race\r\n\r\nPromish wraps the native implementation of race.\r\n\r\n```javascript\r\nPromish.race([promise1, promise2])\r\n  .then(function(value) {\r\n    // first promise to finish was a success\r\n  })\r\n  .catch(function(error) {\r\n    // first promise to finish failed\r\n  });\r\n  \r\n```\r\n\r\n## Some\r\n\r\nResolve on first N successful promises or reject with array of errors.\r\n\r\n```javascript\r\nPromish.some([promise1, promise2, promise3], 2)\r\n  .then(function(values) {\r\n    // first 2 successful promises...\r\n  })\r\n  .catch(function(errors) {\r\n    // at least 2 promises failed\r\n  });\r\n  \r\n```\r\n\r\n## Any\r\n\r\nResolve on first successful promise or reject with array of errors.\r\n\r\n```javascript\r\nPromish.any([promise1, promise2])\r\n  .then(function(value) {\r\n    // first successful promise...\r\n  })\r\n  .catch(function(errors) {\r\n    // all promises failed\r\n  });\r\n  \r\n```\r\n\r\n## Spread\r\n\r\nConvert a resolve value array into arguments\r\n\r\n```javascript\r\nPromish.all([getPromish1(), getPromish2(), getPromish3()])\r\n  .spread(function(a,b,c) {\r\n    // a === value from getPromish1\r\n    // b === value from getPromish2\r\n    // c === value from getPromish3\r\n  });\r\n```\r\n\r\nSpread will also convert an array of promises into their resolved values\r\n\r\n```javascript\r\nnew Promish(function(resolve) {\r\n    resolve([getPromish1(), getPromish2(), getPromish3()])\r\n  })\r\n  .spread(function(a,b,c) {\r\n    // a === value from getPromish1\r\n    // b === value from getPromish2\r\n    // c === value from getPromish3\r\n  });\r\n```\r\n\r\n## Map\r\n\r\nProcess an array of values or promises using supplied callback and resolving with an array of processed values.\r\n\r\n```javascript\r\nfunction processMapValues(value) {\r\n    return value * 2;\r\n}\r\n// static version\r\nPromish.map([getValue(), getPromise()], processMapValues)\r\n    .spread(function(a,b) {\r\n        // a and b are resolved values\r\n    });\r\n    \r\n// inline version\r\nPromish.resolve([getValue(), getPromise()])\r\n    .map(processMapValues)\r\n    .spread(function(a,b) {\r\n        // a and b are resolved values\r\n    });\r\n```\r\n\r\n## Reduce\r\n\r\nProcess an array of values or promises using supplied callback and resolving with a single accumulated values.\r\nThe callback is called with arguments of accumulator and resolved value and returns a value or promise which will be resolved to become the next accuumulator value.\r\nFor further reading on reduce, please consult documentation for Array reduce();\r\n\r\n```javascript\r\nfunction processReduceValues(total, value) {\r\n    return total + value;\r\n}\r\n\r\n// static version\r\nPromish.reduce([getValue(), getPromise()], processReduceValues, 0)\r\n    .then(function(total) {\r\n        //  total will be the sum of all resolved values\r\n    });\r\n    \r\n// inline version\r\nPromish.resolve([getValue(), getPromise()])\r\n    .reduce(processReduceValues)\r\n    .then(function(total) {\r\n        //  total will be the sum of all resolved values\r\n    });\r\n    \r\n```\r\n\r\n# Browserification\r\n\r\nPromish is now also built for browserification both as a standalone bundle and as a module suitable for inclusion into your own browserify build.\r\n\r\n## dist/promish-bundle\r\n\r\nA browserified bundle is included as dist/promish-bundle.js (or dist/promish-bundle.min.js).\r\n  The bundle uses (and includes) the es6-promise module in order to produce a browser friendly bundle.\r\n\r\n## dist/promish-node\r\n\r\nFor node projects that still require older versions of JavaScript (or for including in a different browser bundle),\r\n  a node friendly module has also been included. To use, add the following code:\r\n\r\n```javascript\r\nvar Promish = require('promish/dist/promish-node');\r\n```\r\n\r\nNote that promish-node makes use of ES6 features like Array.from that are not covered by the babel transpile.\r\n  If you need to use promish in a completely ES2015 environment you will need to include some kind of compatable polyfill:\r\n\r\n```javascript\r\n// polyfill ES6 features\r\nrequire('babel-polyfill');\r\n```\r\n\r\n\r\n# Known Issues\r\n\r\n<ul>\r\n    <li>TBD</li>\r\n</ul>\r\n\r\n# Release History\r\n\r\n| Version | Changes |\r\n| ------- | ------- |\r\n| 0.0.1   | <ul><li>Initial Version</li></ul> |\r\n| 0.0.2   | <ul><li><a href=\"#delay\">Promish.delay()</li><li><a href=\"#defer\">Promish.defer()</li></ul> |\r\n| 0.0.3   | <ul><li><a href=\"#delay\">Promish.delay()</li><li><a href=\"#defer\">Promish.defer()</li><li><a href=\"#spread\">Promish.spread()</li></ul> |\r\n| 0.0.4   | <ul><li><a href=\"#apply\">Promish.apply()</li><li><a href=\"#call\">Promish.call()</li></ul> |\r\n| 0.0.5   | <ul><li><a href=\"#promisification\">Promishification</a></li></ul> |\r\n| 0.0.6   | <ul><li>Bugfixes and Documentation</li></ul> |\r\n| 4.2.2   | <ul><li>Updated for compatability with Node v4.<ul><li>Version number matches the version of Node I used when this was published</li><li>For compatability with older 0.x versions, specify Promish version 0.0.8 in your package.json</li></ul></li><li>Refactored to extend Promise instead of wrapping</li></ul> |\r\n| 4.2.3   | <ul><li>Added implict Promish.all to spread</li></ul> |\r\n| 4.2.4   | <ul><li>finally() must not swallow rejection.</li></ul> |\r\n| 4.2.5   | <ul><li>jshint!</li></ul> |\r\n| 4.2.8   | <ul><li>NPM Keywords</li></ul> |\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/guyonroche/promish.git"
  },
  "scripts": {
    "browser-test": "grunt jasmine",
    "build": "grunt build",
    "build-es5": "grunt es5",
    "clean": "rm -rf build/* && rm -rf dist/*",
    "clean-build": "npm run clean && npm run build",
    "jshint": "npm run jshint-lib & npm run jshint-spec",
    "jshint-lib": "node node_modules/jshint/bin/jshint --config ./.jshintrc ./lib --verbose",
    "jshint-spec": "node node_modules/jshint/bin/jshint --config ./.jshintrc-spec ./spec --verbose",
    "prepublish": "npm run clean-build",
    "test": "npm run unit-test && npm run browser-test",
    "unit-test": "mocha spec/unit"
  },
  "version": "5.0.2"
}
